<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>V&nbsp;Generative Recursion</title><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]-->
<link rel="stylesheet" type="text/css" href="part_five.css" media="all">
</head>
<body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellpadding="0" cellspacing="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">▼</a></td><td></td><td><a indepth="true" href="index.html" class="tocviewlink" data-pltdoc="x">How to Design Programs, Second Edition</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right"></td><td><a indepth="true" href="part_prologue.html" class="tocviewlink" data-pltdoc="x">Prologue:<span class="mywbr"> &nbsp;</span> How to Program</a></td></tr><tr><td align="right">I&nbsp;</td><td><a indepth="true" href="part_one.html" class="tocviewlink" data-pltdoc="x">Fixed-<wbr>Size Data</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="i1-2.html" class="tocviewlink" data-pltdoc="x">Intermezzo:<span class="mywbr"> &nbsp;</span> BSL</a></td></tr><tr><td align="right">II&nbsp;</td><td><a indepth="true" href="part_two.html" class="tocviewlink" data-pltdoc="x">Arbitrarily Large Data</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="i2-3.html" class="tocviewlink" data-pltdoc="x">Intermezzo:<span class="mywbr"> &nbsp;</span> Quote, Unquote</a></td></tr><tr><td align="right">III&nbsp;</td><td><a indepth="true" href="part_three.html" class="tocviewlink" data-pltdoc="x">Abstraction</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="intermezzo__scope.html" class="tocviewlink" data-pltdoc="x">Intermezzo:<span class="mywbr"> &nbsp;</span> Scope</a></td></tr><tr><td align="right">IV&nbsp;</td><td><a indepth="true" href="part_4.html" class="tocviewlink" data-pltdoc="x">Intertwined Data</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="i4-5.html" class="tocviewlink" data-pltdoc="x">Intermezzo:<span class="mywbr"> &nbsp;</span> Pattern Matching</a></td></tr><tr><td align="right">V&nbsp;</td><td><a indepth="true" href="part_five.html" class="tocviewselflink" data-pltdoc="x">Generative Recursion</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="i5-6.html" class="tocviewlink" data-pltdoc="x">Intermezzo:<span class="mywbr"> &nbsp;</span> Vectors</a></td></tr><tr><td align="right">VI&nbsp;</td><td><a indepth="true" href="part_six.html" class="tocviewlink" data-pltdoc="x">Accumulators</a></td></tr><tr><td align="right"></td><td><a indepth="true" href="htdp2e-epilogue.html" class="tocviewlink" data-pltdoc="x">Epilogue</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellpadding="0" cellspacing="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">►</a></td><td>V&nbsp;</td><td><a indepth="true" href="part_five.html" class="tocviewselflink" data-pltdoc="x">Generative Recursion</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right">29&nbsp;</td><td><a href="#%28part._sec~3adesign-algo%29" class="tocviewlink" data-pltdoc="x">Designing Algorithms</a></td></tr><tr><td align="right">30&nbsp;</td><td><a href="#%28part._.Material_for_.F.S.Ms%29" class="tocviewlink" data-pltdoc="x">Material for FSMs</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber">29<tt>&nbsp;</tt></span><a href="#%28part._sec~3adesign-algo%29" class="tocsubseclink" data-pltdoc="x">Designing Algorithms</a></td></tr><tr><td><span class="tocsublinknumber">30<tt>&nbsp;</tt></span><a href="#%28part._.Material_for_.F.S.Ms%29" class="tocsubseclink" data-pltdoc="x">Material for FSMs</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a indepth="true" href="i4-5.html" title="backward to &quot;Intermezzo: Pattern Matching&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a indepth="true" href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a indepth="true" href="i5-6.html" title="forward to &quot;Intermezzo: Vectors&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h3>V<tt>&nbsp;</tt><a name="(part._part~3afive)"></a>Generative Recursion</h3><p>The functions we have developed so far fall into two broad categories. On
 one hand, we have the category of functions that encapsulate domain
 knowledge.  On the other hand, we have functions that consume structured
 data. These functions typically decompose their arguments into their
 immediate structural components and then process those components.  If one
 of the immediate components belongs to the same class of data as the
 input, the function is recursive. For that reason, we refer to these
 functions as <span style="font-style: italic;">(structurally) recursive functions</span>.  In some cases,
 however, we also need functions based on a different form of recursion,
 namely, <span style="font-style: italic;">generative recursion</span>.  The study of this form of
 recursion is as old as mathematics and is often called the study of
 <span style="font-style: italic;">algorithms</span>.</p><p>The inputs of an algorithm represent a problem.  Except for rare
 occasions, the problem is an instance of a large class of problems and the
 algorithm works for all of these problems. In general, an algorithm
 partitions a problem into other, smaller problems and solves those. For
 example, an algorithm for planning a vacation trip requires arrangements
 for a trip from our home to a nearby airport, a flight to an airport near
 our vacation spot, and a trip from that airport to our vacation hotel. The
 entire problem is solved by combining the solutions for these problems.</p><p>Designing an algorithm distinguishes two kinds of problems: those that are
 <span style="font-style: italic;">trivially solvable</span><span class="refelem"><span class="refcolumn"><span class="refcontent">For this part of the book, the
word “trivial” is a technical term; see <a href="#%28part._sec~3adesign-algo%29" data-pltdoc="x">Designing Algorithms</a>.</span></span></span>  and
 those that are not. If a given problem is trivially solvable, an algorithm
 produces the matching solution. For example, the problem of getting from
 our home to a nearby airport might be trivially solvable. We can drive
 there, take a cab, or ask a friend to drop us off.  If not, the algorithm
 generates a new problem and solves those new problems. A multistage trip
 is an example of a problem that is non-trivial and can be solved by
 generating new, smaller problems.  In a computational setting one of the
 smaller problems often belongs to the same class of problems as the
 original one, and it is for this reason that we call the approach
 <span style="font-style: italic;">generative recursion</span>.</p><p>In this part of the book, we study the design of algorithms, that is,
 functions based on generative recursion. From the description of the idea,
 we know that this process is much more of an ad hoc activity than the
 data-driven design of structurally recursive functions.  Indeed, it is
 almost better to call it inventing an algorithm than designing
 one. Inventing an algorithm requires a new insight—<wbr>a “eureka.”
 Sometimes very little insight is required. For example, solving a
 “problem” might just require the enumeration of a series of numbers. At
 other times, however, it may rely on a mathematical theorem concerning
 numbers. Or, it may exploit a series of mathematical results on systems of
 equations.  To acquire a good understanding of the design process, it is
 necessary to study examples and to develop a sense for the various classes
 of examples. In practice, new complex algorithms are often developed by
 mathematicians and mathematical computer scientists; programmers, though,
 must throughly understand the underlying ideas so that they can invent the
 simple algorithms on their own and communicate with scientists about the
 others.</p><h3>29<tt>&nbsp;</tt><a name="(part._sec~3adesign-algo)"></a>Designing Algorithms</h3><blockquote class="SCentered"><p><span style="font-weight: bold;">The rest of this chapter is under development.
Use <a href="http://www.htdp.org/">HtDP/1e</a> in the meantime.</span></p></blockquote><h3>30<tt>&nbsp;</tt><a name="(part._.Material_for_.F.S.Ms)"></a>Material for FSMs</h3><p>shows how to use a finite state machine as a tool for
 recognizing a specific pattern in strings or in sequences of
 keystrokes. If you wanted to recognize a different pattern, you would need
 to modify the program in an appropriate manner.</p><p>It should not surprise you that it is possible to create a data
 representation for FSMs or, equivalently, regular expressions. Once you
 have this data representation, you can write a program that recognizes any
 regular-expression pattern in a sequence of keystrokes. As it turns out,
 BSL+ is not quite powerful enough to implement a true generalization of
 the world program called for in <a indepth="true" href="part_one.html#(counter._(exercise._ex~3afsm))" data-pltdoc="x">exercise&nbsp;100</a>. Instead, the objective of
 this section is to design <span class="RktSym">accept</span>, a program that checks whether a
 list of key events is acceptable as specified by a (data representation of
 an) FSM. To design the full program, you will have to wait until we extend
 BSL+ to ISL</p><p></p><div class="SIntrapara">To get started, we need a data representation for FSMs. Every FSM consists
 of a finite number of states. It is common to label states with meaningful
 names but otherwise states have no direct attributes. Hence representing
 states as strings is a natural idea:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><p><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A </span><a name="(tech._state)"></a><span style="font-style: italic;">State</span><span class="RktCmt"> (in an FSM) is a </span><a indepth="true" href="part_one.html#(tech._string)" class="techoutside" data-pltdoc="x"><span class="techinside">String</span></a><span class="RktCmt">.</span></p></blockquote></div><div class="SIntrapara">When you read other books or articles, you may also encounter natural
 numbers or other representations.</div><p></p><p>An FSM itself has three critical attributes as far as we are concerned: its
 initial state, its possible final states, and transitions between
 states, which implicitly specifies the finite states of the FSM.
 A transition also has three attributes: the state in which
 a <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a> is acceptable; the list of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s that make
 the machine transition to another state; and the end state of the
 transition.</p><p></p><div class="SIntrapara">We introduce two distinct structure types to keep track of these attributes:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table class="RktBlk" cellspacing="0"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define-struct</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">initial</span><span class="hspace">&nbsp;</span><span class="RktSym">finals</span><span class="hspace">&nbsp;</span><span class="RktSym">transitions</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define-struct</span><span class="hspace">&nbsp;</span><span class="RktSym">transition</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">current</span><span class="hspace">&nbsp;</span><span class="RktSym">keys</span><span class="hspace">&nbsp;</span><span class="RktSym">next</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The data definitions for these two structure types just translate the
 informal prose from above into rigorous comments:
</div><div class="SIntrapara"><table cellspacing="0"><tbody><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; A {FSM} is</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">racket[(make-fsm tech{State} tech{State*} tech{Transition*})]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; A {Transition} is</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">racket[(make-transition tech{State} tech{KE*} tech{State})]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; A {State*} is one of:</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[empty]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[(cons tech{State} tech{State*})]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; A {Transition*} is one of</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[empty]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[(cons tech{Transition} tech{Transition*})]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span><span class="stt">;; A {KE*} is one of</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[empty]</span></span></p></td></tr><tr><td><p><span class="stt"><span class="hspace">&nbsp;&nbsp;</span>;;<span class="hspace">&nbsp;&nbsp;</span><span class="stt">-- racket[(cons tech{KeyEvent} tech{KE*})]</span></span></p></td></tr></tbody></table></div><p></p><p></p><div class="SIntrapara">While this collection of data definitions appears to be complex, it is
 straightforward and representative of real-world problems. It may bother
 you that we need that many words to say that
</div><div class="SIntrapara"><ul><li><p>A machine representation consists of an <span class="RktSym">initial</span> state, a
collection of <span class="RktSym">final</span> states, and a list of <span class="RktSym">transitions</span>.</p></li><li><p>A single transition consists of the <span class="RktSym">current</span> state, plus the
list of <span class="RktSym">keys</span> that a user may hit to reach the <span class="RktSym">next</span>
state.</p></li></ul></div><div class="SIntrapara">The next chapter explains why using this many words is actually bad and
 what we can do about it. For now, we have written down these three data
 definitions for lists of <a href="#%28tech._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">State</span></a>s, <a indepth="true" href="part_two.html#(tech._transition)" class="techoutside" data-pltdoc="x"><span class="techinside">Transition</span></a>s, and
 <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s, and you will solve problems that process this kind of
 data.</div><p></p><p>In addition to the explicitly specified states of an <a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a>, we assume
 that it has one more: <span class="RktPn">(</span><span class="RktSym">define</span><span class="stt"> </span><span class="RktSym">ER</span><span class="stt"> </span><span class="RktVal">"error"</span><span class="RktPn">)</span>, the error
 state. Whenever an <span class="RktSym">FSM</span> encounters an erroneous input, it
 transitions to this special state and stops running.</p><blockquote class="SubFlow"><p></p><div class="SIntrapara"><a name="(counter._(exercise._ex~3afsm-data-example))"></a><span style="font-weight: bold;">Exercise</span>&nbsp;332. Translate the finite state machine from
 <a indepth="true" href="part_one.html#(counter._(exercise._ex~3afsm))" data-pltdoc="x">exercise&nbsp;100</a> into an element of <a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a>. Introduce separate
 definitions:
</div><div class="SIntrapara"><ul><li><p><span class="RktSym">i0</span> for the initial state;</p></li><li><p><span class="RktSym">f*</span> for the list of final states;</p></li><li><p><span class="RktSym">t*</span> for the list of transitions.</p></li></ul></div><div class="SIntrapara">Name the machine itself <span class="RktSym">fsm0</span>. <img src="qed.png" alt=""></div><p></p></blockquote><p></p><div class="SIntrapara">Now we are finally ready for the design of <span class="RktSym">accept</span>. Following the
 design recipe, we translate the problem statement and the data definitions
 into a signature, a purpose statement, and a dummy header:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table class="RktBlk" cellspacing="0"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tech{KE*} </span><a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a><span class="RktCmt"> -&gt; </span><a indepth="true" href="part_one.html#(tech._boolean)" class="techoutside" data-pltdoc="x"><span class="techinside">Boolean</span></a><span class="RktCmt"> </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">is the sequence </span><span class="RktSym">ke</span><span class="RktCmt"> of </span><a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a><span class="RktCmt">s acceptable to </span><span class="RktSym">fsm</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">accept</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">As requested, the function consumes a sequence of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s and an
 <a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a>, and like all function whose problem statements mention
 “whether,” it produces a <a indepth="true" href="part_one.html#(tech._boolean)" class="techoutside" data-pltdoc="x"><span class="techinside">Boolean</span></a>. Given your current knowledge of
 design, however, you cannot design the (core of the) actual function. To
 create this function systematically from the problem statement, you need
 not just one but two additional pieces of program design knowledge:
 generative recursion and accumulators, which this book presents in
 <a indepth="true" href="part_five.html" data-pltdoc="x">Generative Recursion</a> and <a indepth="true" href="part_six.html" data-pltdoc="x">Accumulators</a>, respectively.</div><p></p><blockquote class="SubFlow"><p><a name="(counter._(exercise._ex~3afsm-accept-tests))"></a><span style="font-weight: bold;">Exercise</span>&nbsp;333. Formulate functional examples for
<span class="RktSym">accept</span> using your solution for <a href="#%28counter._%28exercise._ex~3afsm-data-example%29%29" data-pltdoc="x">exercise&nbsp;332</a>. <img src="qed.png" alt=""></p></blockquote><p></p><div class="SIntrapara"><a href="#%28counter._%28figure._fig~3afsm-accept%29%29" data-pltdoc="x">Figure&nbsp;<span class="FigureRef">76</span></a> presents <span class="RktSym">accept</span> and <span class="RktSym">aux</span>, its
 auxiliary function. The former extracts the three pieces of the given
 <a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a> and hands them to <span class="RktSym">aux</span> together with the sequence of
 <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s. The latter is the “workhorse” of the program. It use a
 four-pronged conditional to determine the situation that its inputs
 describe:
</div><div class="SIntrapara"><ol><li><p><span class="RktPn">(</span><span class="RktSym">empty?</span><span class="stt"> </span><span class="RktSym">ke*</span><span class="RktPn">)</span> means that the sequence of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s is
empty. Since a sequence is considered acceptable if the current state of
the program is a final state, the answer is just this test.</p></li><li><p><span class="RktPn">(</span><span class="RktSym">member?</span><span class="stt"> </span><span class="RktSym">crt</span><span class="stt"> </span><span class="RktSym">fnl*</span><span class="RktPn">)</span> asks whether some state <span class="RktSym">crt</span> is a
member of the given list of final states. If so, the program has
discovered an acceptable sequence of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s—<wbr>up to this
point. Note that if this were a world program, the <span class="RktSym">stop-when</span>
clause would cause it to shut down.</p></li><li><p>The third case, <span class="RktPn">(</span><span class="RktSym">stuck?</span><span class="stt"> </span><span class="RktSym">trns*</span><span class="stt"> </span><span class="RktSym">crt</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ke*</span><span class="RktPn">)</span><span class="RktPn">)</span>, uses
another, yet-to-be-defined auxiliary function, <span class="RktSym">possible?</span>, to
determine whether the list of transitions <span class="RktSym">trns*</span> specifies a
successor state to <span class="RktSym">crt</span> for the first <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a> in the
sequence. If not, the machine is considered stuck, meaning the sequence is
unacceptable.</p></li><li><p>Otherwise, we know that (1) the sequence of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s is not
exhausted yet, (2) the current state is not a final state, and (3)
<span class="RktSym">trns*</span> contains a transition in from <span class="RktSym">crt</span> to some other
state for <span class="RktPn">(</span><span class="RktSym">first</span><span class="stt"> </span><span class="RktSym">ke*</span><span class="RktPn">)</span>.</p></li></ol></div><div class="SIntrapara">As you can see, the last state uses a recursive call to <span class="RktSym">aux</span> to
 continue the exploration of the sequence of <a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a>s. Instead of
 <span class="RktSym">crt</span>, <span class="RktSym">aux</span> uses the state determined by <span class="RktSym">next</span>, a
 second auxiliary function. Your task is to design the two auxiliary
 functions.</div><p></p><blockquote class="SubFlow"><p></p><div class="SIntrapara"><a name="(counter._(exercise._ex~3afsm-stuck))"></a><span style="font-weight: bold;">Exercise</span>&nbsp;334. Design the function <span class="RktSym">stuck?</span>. Here is the
wish list entry:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table class="RktBlk" cellspacing="0"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><a indepth="true" href="part_two.html#(tech._transition*)" class="techoutside" data-pltdoc="x"><span class="techinside">Transition*</span></a><span class="RktCmt"> </span><a href="#%28tech._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">State</span></a><span class="RktCmt"> </span><a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a><span class="RktCmt"> -&gt; </span><a indepth="true" href="part_one.html#(tech._boolean)" class="techoutside" data-pltdoc="x"><span class="techinside">Boolean</span></a></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stuck?</span><span class="hspace">&nbsp;</span><span class="RktSym">t*</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktSym">ke</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The function ensures that none of the transitions in <span class="RktSym">t*</span> has a
current state <span class="RktSym">c</span> with <span class="RktSym">ke</span> a member of its keys. <img src="qed.png" alt=""></div><p></p></blockquote><blockquote class="SubFlow"><p></p><div class="SIntrapara"><a name="(counter._(exercise._ex~3afsm-next))"></a><span style="font-weight: bold;">Exercise</span>&nbsp;335. Design the function <span class="RktSym">next</span>. It comes with
this wish list entry:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table class="RktBlk" cellspacing="0"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><a indepth="true" href="part_two.html#(tech._transition*)" class="techoutside" data-pltdoc="x"><span class="techinside">Transition*</span></a><span class="RktCmt"> </span><a href="#%28tech._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">State</span></a><span class="RktCmt"> </span><a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a><span class="RktCmt"> -&gt; </span><a href="#%28tech._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">State</span></a></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">stuck?</span><span class="hspace">&nbsp;</span><span class="RktSym">t*</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktSym">ke</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">crt</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The function retrieves the next state from a <span class="RktPn">(</span><span class="RktSym">make-transition</span><span class="stt"> </span><span class="RktSym">crt</span><span class="stt"> </span><span class="RktSym">keys</span><span class="stt"> </span><span class="RktSym">next</span><span class="RktPn">)</span> in <span class="RktSym">t*</span> if <span class="RktSym">ke</span> is a member of <span class="RktSym">keys</span>.
If there is no such item in <span class="RktSym">t*</span>, signal the error
<span class="RktVal">"can't happen"</span>
because we assume that the function is called only when <span class="RktPn">(</span><span class="RktSym">stuck?</span><span class="stt"> </span><span class="RktSym">t*</span><span class="stt"> </span><span class="RktSym">crt</span><span class="stt"> </span><span class="RktSym">ke</span><span class="RktPn">)</span> is <span class="RktSym">false</span>. <img src="qed.png" alt=""></div><p></p></blockquote><blockquote class="SubFlow"><p><a name="(counter._(exercise._ex~3afsm-test-all))"></a><span style="font-weight: bold;">Exercise</span>&nbsp;336. Integrate your solutions to the preceding two
exercises with the definitions in <a href="#%28counter._%28figure._fig~3afsm-accept%29%29" data-pltdoc="x">figure&nbsp;<span class="FigureRef">76</span></a> and make sure
all functions pass all their tests. <img src="qed.png" alt=""></p></blockquote><blockquote class="Figure"><blockquote class="Centerfigure"><blockquote class="FigureInside"><blockquote class="SCodeFlow"><table class="RktBlk" cellspacing="0"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tech{KE*} </span><a indepth="true" href="part_two.html#(tech._fsm)" class="techoutside" data-pltdoc="x"><span class="techinside">FSM</span></a><span class="RktCmt"> -&gt; </span><a indepth="true" href="part_one.html#(tech._boolean)" class="techoutside" data-pltdoc="x"><span class="techinside">Boolean</span></a><span class="RktCmt"> </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">is the sequence </span><span class="RktSym">ke</span><span class="RktCmt"> of </span><a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a><span class="RktCmt">s acceptable to </span><span class="RktSym">fsm</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">accept</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"c"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">accept</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"c"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="hspace">&nbsp;</span><span class="RktVal">"e"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">accept</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"left"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">accept</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fsm-initial</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fsm-finals</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fsm-transitions</span><span class="hspace">&nbsp;</span><span class="RktSym">fsm</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tech{KE*} </span><a href="#%28tech._state%29" class="techoutside" data-pltdoc="x"><span class="techinside">State</span></a><span class="RktCmt"> tech{State*} </span><a indepth="true" href="part_two.html#(tech._transition*)" class="techoutside" data-pltdoc="x"><span class="techinside">Transition*</span></a><span class="RktCmt"> -&gt; </span><a indepth="true" href="part_one.html#(tech._boolean)" class="techoutside" data-pltdoc="x"><span class="techinside">Boolean</span></a><span class="RktCmt"> </span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">is the sequence </span><span class="RktSym">ke</span><span class="RktCmt"> of </span><a indepth="true" href="part_one.html#(tech._keyevent)" class="techoutside" data-pltdoc="x"><span class="techinside">KeyEvent</span></a><span class="RktCmt">s acceptable to an FSM</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">equivalent to </span><span class="RktPn">(</span><span class="RktSym">make-fsm</span><span class="stt"> </span><span class="RktSym">crt</span><span class="stt"> </span><span class="RktSym">fnl*</span><span class="stt"> </span><span class="RktSym">trns*</span><span class="RktPn">)</span><span class="RktCmt"> ? </span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"c"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">i0</span><span class="hspace">&nbsp;</span><span class="RktSym">f0</span><span class="hspace">&nbsp;</span><span class="RktSym">t*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"c"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="hspace">&nbsp;</span><span class="RktVal">"e"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">i0</span><span class="hspace">&nbsp;</span><span class="RktSym">f0</span><span class="hspace">&nbsp;</span><span class="RktSym">t*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">"a"</span><span class="hspace">&nbsp;</span><span class="RktVal">"b"</span><span class="hspace">&nbsp;</span><span class="RktVal">"left"</span><span class="hspace">&nbsp;</span><span class="RktVal">"d"</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">i0</span><span class="hspace">&nbsp;</span><span class="RktSym">f0</span><span class="hspace">&nbsp;</span><span class="RktSym">t*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktSym">fnl*</span><span class="hspace">&nbsp;</span><span class="RktSym">trns*</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cond</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">empty?</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member?</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktSym">fnl*</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">member?</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktSym">fnl*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">stuck?</span><span class="hspace">&nbsp;</span><span class="RktSym">trns*</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aux</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rest</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">next</span><span class="hspace">&nbsp;</span><span class="RktSym">trns*</span><span class="hspace">&nbsp;</span><span class="RktSym">crt</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">first</span><span class="hspace">&nbsp;</span><span class="RktSym">ke*</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">fnl*</span><span class="hspace">&nbsp;</span><span class="RktSym">trns*</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></blockquote></blockquote><p class="Centertext"><span class="Legend"><span class="FigureTarget"><a name="(counter._(figure._fig~3afsm-accept))"></a>Figure&nbsp;76: </span>Accepting regular expressions</span></p></blockquote><div class="navsetbottom"><span class="navleft">&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a indepth="true" href="i4-5.html" title="backward to &quot;Intermezzo: Pattern Matching&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a indepth="true" href="index.html" title="up to &quot;How to Design Programs, Second Edition&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a indepth="true" href="i5-6.html" title="forward to &quot;Intermezzo: Vectors&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div>

</body></html>
